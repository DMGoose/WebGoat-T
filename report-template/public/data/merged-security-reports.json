[
  {
    "tool": "CodeQL",
    "type": "SAST",
    "timestamp": "2025-10-21T07:37:59.972271+00:00",
    "target": "source-code",
    "results": [
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/clear-text-storage-of-sensitive-data",
        "severity": "7.5",
        "message": "This stores sensitive data returned by [an access to apiToken](1) as clear text.",
        "short_description": "Clear text storage of sensitive information",
        "full_description": "Sensitive information stored without encryption or hashing can expose it to an attacker.",
        "remediation": "# Clear text storage of sensitive information\nSensitive information that is stored unencrypted is accessible to an attacker who gains access to the storage. This is particularly important for cookies, which are stored on the machine of the end-user.\n\n\n## Recommendation\nEnsure that sensitive information is always encrypted before being stored. If possible, avoid placing sensitive information in cookies altogether. Instead, prefer storing, in the cookie, a key that can be used to look up the sensitive information.\n\nIn general, decrypt sensitive information only at the point where it is necessary for it to be used in cleartext.\n\nBe aware that external processes often store the `standard out` and `standard error` streams of the application, causing logged sensitive information to be stored as well.\n\n\n## Example\nThe following example code stores user credentials (in this case, their password) in a cookie in plain text:\n\n\n```javascript\nvar express = require('express');\n\nvar app = express();\napp.get('/remember-password', function (req, res) {\n  let pw = req.param(\"current_password\");\n  // BAD: Setting a cookie value with cleartext sensitive data.\n  res.cookie(\"password\", pw);\n});\n\n```\nInstead, the credentials should be encrypted, for instance by using the Node.js `crypto` module:\n\n\n```javascript\nvar express = require('express');\nvar crypto = require('crypto'),\n    password = getPassword();\n\nfunction encrypt(text){\n  var cipher = crypto.createCipher('aes-256-ctr', password);\n  return cipher.update(text, 'utf8', 'hex') + cipher.final('hex');\n}\n\nvar app = express();\napp.get('/remember-password', function (req, res) {\n  let pw = req.param(\"current_password\");\n  // GOOD: Encoding the value before setting it.\n  res.cookie(\"password\", encrypt(pw));\n});\n\n```\n\n## References\n* M. Dowd, J. McDonald and J. Schuhm, *The Art of Software Security Assessment*, 1st Edition, Chapter 2 - 'Common Vulnerabilities of Encryption', p. 43. Addison Wesley, 2006.\n* M. Howard and D. LeBlanc, *Writing Secure Code*, 2nd Edition, Chapter 9 - 'Protecting Secret Data', p. 299. Microsoft, 2002.\n* Common Weakness Enumeration: [CWE-312](https://cwe.mitre.org/data/definitions/312.html).\n* Common Weakness Enumeration: [CWE-315](https://cwe.mitre.org/data/definitions/315.html).\n* Common Weakness Enumeration: [CWE-359](https://cwe.mitre.org/data/definitions/359.html).\n",
        "reference": "",
        "file": "src/main/resources/lessons/jwt/js/jwt-refresh.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/html-constructed-from-input",
        "severity": "6.1",
        "message": "This HTML construction which depends on [library input](1) might later allow [cross-site scripting](2).",
        "short_description": "Unsafe HTML constructed from library input",
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "remediation": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/jquery_form/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/html-constructed-from-input",
        "severity": "6.1",
        "message": "This HTML construction which depends on [library input](1) might later allow [cross-site scripting](2).",
        "short_description": "Unsafe HTML constructed from library input",
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "remediation": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/libs/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/html-constructed-from-input",
        "severity": "6.1",
        "message": "This HTML construction which depends on [library input](1) might later allow [cross-site scripting](2).",
        "short_description": "Unsafe HTML constructed from library input",
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "remediation": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/libs/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/html-constructed-from-input",
        "severity": "6.1",
        "message": "This HTML construction which depends on [library input](1) might later allow [cross-site scripting](2).",
        "short_description": "Unsafe HTML constructed from library input",
        "full_description": "Using externally controlled strings to construct HTML might allow a malicious user to perform a cross-site scripting attack.",
        "remediation": "# Unsafe HTML constructed from library input\nWhen a library function dynamically constructs HTML in a potentially unsafe way, then it's important to document to clients of the library that the function should only be used with trusted inputs. If the function is not documented as being potentially unsafe, then a client may inadvertently use inputs containing unsafe HTML fragments, and thereby leave the client vulnerable to cross-site scripting attacks.\n\n\n## Recommendation\nDocument all library functions that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example has a library function that renders a boldface name by writing to the `innerHTML` property of an element.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + name + \"</b>\";\n}\n\n```\nThis library function, however, does not escape unsafe HTML, and a client that calls the function with user-supplied input may be vulnerable to cross-site scripting attacks.\n\nThe library could either document that this function should not be used with unsafe inputs, or use safe APIs such as `innerText`.\n\n\n```javascript\nmodule.exports = function showBoldName(name) {\n  const bold = document.createElement('b');\n  bold.innerText = name;\n  document.getElementById('name').appendChild(bold);\n}\n\n```\nAlternatively, an HTML sanitizer can be used to remove unsafe content.\n\n\n```javascript\n\nconst striptags = require('striptags');\nmodule.exports = function showBoldName(name) {\n  document.getElementById('name').innerHTML = \"<b>\" + striptags(name) + \"</b>\";\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://www.owasp.org/index.php/XSS_%28Cross_Site_Scripting%29_Prevention_Cheat_Sheet).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/jquery_form/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/xss-through-dom",
        "severity": "6.1",
        "message": "[DOM text](1) is reinterpreted as HTML without escaping meta-characters.",
        "short_description": "DOM text reinterpreted as HTML",
        "full_description": "Reinterpreting text from the DOM as HTML can lead to a cross-site scripting vulnerability.",
        "remediation": "# DOM text reinterpreted as HTML\nExtracting text from a DOM node and interpreting it as HTML can lead to a cross-site scripting vulnerability.\n\nA webpage with this vulnerability reads text from the DOM, and afterwards adds the text as HTML to the DOM. Using text from the DOM as HTML effectively unescapes the text, and thereby invalidates any escaping done on the text. If an attacker is able to control the safe sanitized text, then this vulnerability can be exploited to perform a cross-site scripting attack.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing text to the page, or one of the other solutions that are mentioned in the References section below.\n\n\n## Example\nThe following example shows a webpage using a `data-target` attribute to select and manipulate a DOM element using the JQuery library. In the example, the `data-target` attribute is read into the `target` variable, and the `$` function is then supposed to use the `target` variable as a CSS selector to determine which element should be manipulated.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n    $(target).hide();\n});\n\n```\nHowever, if an attacker can control the `data-target` attribute, then the value of `target` can be used to cause the `$` function to execute arbitrary JavaScript.\n\nThe above vulnerability can be fixed by using `$.find` instead of `$`. The `$.find` function will only interpret `target` as a CSS selector and never as HTML, thereby preventing an XSS attack.\n\n\n```javascript\n$(\"button\").click(function () {\n    var target = $(this).attr(\"data-target\");\n\t$.find(target).hide();\n});\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://owasp.org/www-community/attacks/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://owasp.org/www-community/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/lessons/htmltampering/html/HtmlTampering.html"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/unsafe-jquery-plugin",
        "severity": "6.1",
        "message": "Potential XSS vulnerability in the ['$.fn.ajaxSubmit' plugin](1).",
        "short_description": "Unsafe jQuery plugin",
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "remediation": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/jquery_form/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/unsafe-jquery-plugin",
        "severity": "6.1",
        "message": "Potential XSS vulnerability in the ['$.fn.ajaxSubmit' plugin](1).",
        "short_description": "Unsafe jQuery plugin",
        "full_description": "A jQuery plugin that unintentionally constructs HTML from some of its options may be unsafe to use for clients.",
        "remediation": "# Unsafe jQuery plugin\nLibrary plugins, such as those for the jQuery library, are often configurable through options provided by the clients of the plugin. Clients, however, do not know the implementation details of the plugin, so it is important to document the capabilities of each option. The documentation for the plugin options that the client is responsible for sanitizing is of particular importance. Otherwise, the plugin may write user input (for example, a URL query parameter) to a web page without properly sanitizing it first, which allows for a cross-site scripting vulnerability in the client application through dynamic HTML construction.\n\n\n## Recommendation\nDocument all options that can lead to cross-site scripting attacks, and guard against unsafe inputs where dynamic HTML construction is not intended.\n\n\n## Example\nThe following example shows a jQuery plugin that selects a DOM element, and copies its text content to another DOM element. The selection is performed by using the plugin option `sourceSelector` as a CSS selector.\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// BAD may evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\nThis is, however, not a safe plugin, since the call to `jQuery` interprets `sourceSelector` as HTML if it is a string that starts with `<`.\n\nInstead of documenting that the client is responsible for sanitizing `sourceSelector`, the plugin can use `jQuery.find` to always interpret `sourceSelector` as a CSS selector:\n\n\n```javascript\njQuery.fn.copyText = function(options) {\n\t// GOOD may not evaluate `options.sourceSelector` as HTML\n\tvar source = jQuery.find(options.sourceSelector),\n\t    text = source.text();\n\tjQuery(this).text(text);\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://www.owasp.org/index.php/DOM_based_XSS_Prevention_Cheat_Sheet).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* jQuery: [Plugin creation](https://learn.jquery.com/plugins/basic-plugin-creation/).\n* Bootstrap: [XSS vulnerable bootstrap plugins](https://github.com/twbs/bootstrap/pull/27047).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/libs/jquery.form.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/incomplete-sanitization",
        "severity": "7.8",
        "message": "This does not escape backslash characters in the input.",
        "short_description": "Incomplete string escaping or encoding",
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "remediation": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/libs/jquery-ui-1.10.4.js"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-js",
        "rule_id": "js/incomplete-sanitization",
        "severity": "7.8",
        "message": "This does not escape backslash characters in the input.",
        "short_description": "Incomplete string escaping or encoding",
        "full_description": "A string transformer that does not replace or escape all occurrences of a meta-character may be ineffective.",
        "remediation": "# Incomplete string escaping or encoding\nSanitizing untrusted input is a common technique for preventing injection attacks such as SQL injection or cross-site scripting. Usually, this is done by escaping meta-characters such as quotes in a domain-specific way so that they are treated as normal characters.\n\nHowever, directly using the string `replace` method to perform escaping is notoriously error-prone. Common mistakes include only replacing the first occurrence of a meta-character, or backslash-escaping various meta-characters but not the backslash itself.\n\nIn the former case, later meta-characters are left undisturbed and can be used to subvert the sanitization. In the latter case, preceding a meta-character with a backslash leads to the backslash being escaped, but the meta-character appearing un-escaped, which again makes the sanitization ineffective.\n\nEven if the escaped string is not used in a security-critical context, incomplete escaping may still have undesirable effects, such as badly rendered or confusing output.\n\n\n## Recommendation\nUse a (well-tested) sanitization library if at all possible. These libraries are much more likely to handle corner cases correctly than a custom implementation.\n\nAn even safer alternative is to design the application so that sanitization is not needed, for instance by using prepared statements for SQL queries.\n\nOtherwise, make sure to use a regular expression with the `g` flag to ensure that all occurrences are replaced, and remember to escape backslashes if applicable.\n\n\n## Example\nFor example, assume that we want to embed a user-controlled string `accountNumber` into a SQL query as part of a string literal. To avoid SQL injection, we need to ensure that the string does not contain un-escaped single-quote characters. The following function attempts to ensure this by doubling single quotes, and thereby escaping them:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(\"'\", \"''\");\n}\n\n```\nAs written, this sanitizer is ineffective: if the first argument to `replace` is a string literal (as in this case), only the *first* occurrence of that string is replaced.\n\nAs mentioned above, the function `escapeQuotes` should be replaced with a purpose-built sanitization library, such as the npm module `sqlstring`. Many other sanitization libraries are available from npm and other sources.\n\nIf this is not an option, `escapeQuotes` should be rewritten to use a regular expression with the `g` (\"global\") flag instead:\n\n\n```javascript\nfunction escapeQuotes(s) {\n  return s.replace(/'/g, \"''\");\n}\n\n```\nNote that it is very important to include the global flag: `s.replace(/'/, \"''\")` *without* the global flag is equivalent to the first example above and only replaces the first quote.\n\n\n## References\n* OWASP Top 10: [A1 Injection](https://www.owasp.org/index.php/Top_10-2017_A1-Injection).\n* npm: [sqlstring](https://www.npmjs.com/package/sqlstring) package.\n* Common Weakness Enumeration: [CWE-20](https://cwe.mitre.org/data/definitions/20.html).\n* Common Weakness Enumeration: [CWE-80](https://cwe.mitre.org/data/definitions/80.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
        "reference": "",
        "file": "src/main/resources/webgoat/static/js/libs/jquery-ui-1.10.4.js"
      }
    ]
  },
  {
    "tool": "CodeQL",
    "type": "SAST",
    "timestamp": "2025-10-21T07:37:59.986299+00:00",
    "target": "source-code",
    "results": [
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/insecure-randomness",
        "severity": "7.8",
        "message": "Potential Insecure randomness due to a [Insecure randomness source.](1).",
        "short_description": "Insecure randomness",
        "full_description": "Using a cryptographically Insecure pseudo-random number generator to generate a security-sensitive value may allow an attacker to predict what value will be generated.",
        "remediation": "# Insecure randomness\nIf you use a cryptographically weak pseudo-random number generator to generate security-sensitive values, such as passwords, attackers can more easily predict those values.\n\nPseudo-random number generators generate a sequence of numbers that only approximates the properties of random numbers. The sequence is not truly random because it is completely determined by a relatively small set of initial values (the seed). If the random number generator is cryptographically weak, then this sequence may be easily predictable through outside observations.\n\n\n## Recommendation\nThe `java.util.Random` random number generator is not cryptographically secure. Use a secure random number generator such as `java.security.SecureRandom` instead.\n\nUse a cryptographically secure pseudo-random number generator if the output is to be used in a security-sensitive context. As a general rule, a value should be considered \"security-sensitive\" if predicting it would allow the attacker to perform an action that they would otherwise be unable to perform. For example, if an attacker could predict the random password generated for a new user, they would be able to log in as that new user.\n\n\n## Example\nThe following examples show different ways of generating a cookie with a random value.\n\nIn the first (BAD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`Random`) is not cryptographically secure, so it may be possible for an attacker to predict the generated cookie.\n\n\n```java\nRandom r = new Random(); // BAD: Random is not cryptographically secure\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\nIn the second (GOOD) case, we generate a fresh cookie by appending a random integer to the end of a static string. The random number generator used (`SecureRandom`) is cryptographically secure, so it is not possible for an attacker to predict the generated cookie.\n\n\n```java\nSecureRandom r = new SecureRandom(); // GOOD: SecureRandom is cryptographically secure\n\nbyte[] bytes = new byte[16];\nr.nextBytes(bytes);\n\nString cookieValue = encode(bytes);\n\nCookie cookie = new Cookie(\"name\", cookieValue);\nresponse.addCookie(cookie);\n\n```\n\n## References\n* Wikipedia: [Pseudo-random number generator](http://en.wikipedia.org/wiki/Pseudorandom_number_generator).\n* Java Docs: [Random](http://docs.oracle.com/javase/8/docs/api/java/util/Random.html).\n* Java Docs: [SecureRandom](http://docs.oracle.com/javase/8/docs/api/java/security/SecureRandom.html).\n* Common Weakness Enumeration: [CWE-330](https://cwe.mitre.org/data/definitions/330.html).\n* Common Weakness Enumeration: [CWE-338](https://cwe.mitre.org/data/definitions/338.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/container/users/UserService.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/challenges/challenge5/Assignment5.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/claimmisuse/JWTHeaderKIDEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionChallenge.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson10.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson2.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson3.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).\nThis query depends on a [user-provided value](3).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson4.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).\nThis query depends on a [user-provided value](3).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5a.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson5b.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson9.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).\nThis query depends on a [user-provided value](2).\nThis query depends on a [user-provided value](3).\nThis query depends on a [user-provided value](4).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/introduction/SqlInjectionLesson8.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/sql-injection",
        "severity": "8.8",
        "message": "This query depends on a [user-provided value](1).",
        "short_description": "Query built from user-controlled sources",
        "full_description": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
        "remediation": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/Servers.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/zipslip",
        "severity": "7.5",
        "message": "Unsanitized archive entry, which may contain '..', is used in a [file system operation](1).",
        "short_description": "Arbitrary file access during archive extraction (\"Zip Slip\")",
        "full_description": "Extracting files from a malicious ZIP file, or similar type of archive, without validating that the destination file path is within the destination directory can allow an attacker to unexpectedly gain access to resources.",
        "remediation": "# Arbitrary file access during archive extraction (\"Zip Slip\")\nExtracting files from a malicious zip file, or similar type of archive, is at risk of directory traversal attacks if filenames from the archive are not properly validated.\n\nZip archives contain archive entries representing each file in the archive. These entries include a file path for the entry, but these file paths are not restricted and may contain unexpected special elements such as the directory traversal element (`..`). If these file paths are used to create a filesystem path, then a file operation may happen in an unexpected location. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nFor example, if a zip file contains a file entry `..\\sneaky-file`, and the zip file is extracted to the directory `c:\\output`, then naively combining the paths would result in an output file path of `c:\\output\\..\\sneaky-file`, which would cause the file to be written to `c:\\sneaky-file`.\n\n\n## Recommendation\nEnsure that output paths constructed from zip archive entries are validated to prevent writing files to unexpected locations.\n\nThe recommended way of writing an output file from a zip archive entry is to verify that the normalized full path of the output file starts with a prefix that matches the destination directory. Path normalization can be done with either `java.io.File.getCanonicalFile()` or `java.nio.file.Path.normalize()`. Prefix checking can be done with `String.startsWith(..)`, but it is better to use `java.nio.file.Path.startsWith(..)`, as the latter works on complete path segments.\n\nAnother alternative is to validate archive entries against a whitelist of expected files.\n\n\n## Example\nIn this example, a file path taken from a zip archive item entry is combined with a destination directory. The result is used as the destination file path without verifying that the result is within the destination directory. If provided with a zip file containing an archive path like `..\\sneaky-file`, then this file would be written outside the destination directory.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    FileOutputStream fos = new FileOutputStream(file); // BAD\n    // ... write entry to fos ...\n}\n\n```\nTo fix this vulnerability, we need to verify that the normalized `file` still has `destinationDir` as its prefix, and throw an exception if this is not the case.\n\n\n```java\nvoid writeZipEntry(ZipEntry entry, File destinationDir) {\n    File file = new File(destinationDir, entry.getName());\n    if (!file.toPath().normalize().startsWith(destinationDir.toPath()))\n        throw new Exception(\"Bad zip entry\");\n    FileOutputStream fos = new FileOutputStream(file); // OK\n    // ... write entry to fos ...\n}\n\n```\n\n## References\n* Snyk: [Zip Slip Vulnerability](https://snyk.io/research/zip-slip-vulnerability).\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).\nThis path depends on a [user-provided value](3).\nThis path depends on a [user-provided value](4).\nThis path depends on a [user-provided value](5).\nThis path depends on a [user-provided value](6).\nThis path depends on a [user-provided value](7).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).\nThis path depends on a [user-provided value](3).\nThis path depends on a [user-provided value](4).\nThis path depends on a [user-provided value](5).\nThis path depends on a [user-provided value](6).\nThis path depends on a [user-provided value](7).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).\nThis path depends on a [user-provided value](3).\nThis path depends on a [user-provided value](4).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).\nThis path depends on a [user-provided value](3).\nThis path depends on a [user-provided value](4).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).\nThis path depends on a [user-provided value](3).\nThis path depends on a [user-provided value](4).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadBase.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileZipSlip.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/pathtraversal/ProfileUploadRetrieval.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xxe/BlindSendFileAssignment.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/webwolf/FileServer.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/path-injection",
        "severity": "7.5",
        "message": "This path depends on a [user-provided value](1).\nThis path depends on a [user-provided value](2).",
        "short_description": "Uncontrolled data used in path expression",
        "full_description": "Accessing paths influenced by users can allow an attacker to access unexpected resources.",
        "remediation": "# Uncontrolled data used in path expression\nAccessing paths controlled by users can allow an attacker to access unexpected resources. This can result in sensitive information being revealed or deleted, or an attacker being able to influence behavior by modifying unexpected files.\n\nPaths that are naively constructed from data controlled by a user may be absolute paths, or may contain unexpected special characters such as \"..\". Such a path could point anywhere on the file system.\n\n\n## Recommendation\nValidate user input before using it to construct a file path.\n\nCommon validation methods include checking that the normalized path is relative and does not contain any \"..\" components, or checking that the path is contained within a safe folder. The method you should use depends on how the path is used in the application, and whether the path should be a single path component.\n\nIf the path should be a single path component (such as a file name), you can check for the existence of any path separators (\"/\" or \"\\\\\"), or \"..\" sequences in the input, and reject the input if any are found.\n\nNote that removing \"../\" sequences is *not* sufficient, since the input could still contain a path separator followed by \"..\". For example, the input \".../...//\" would still result in the string \"../\" if only \"../\" sequences are removed.\n\nFinally, the simplest (but most restrictive) option is to use an allow list of safe patterns and make sure that the user input matches one of these patterns.\n\n\n## Example\nIn this example, a file name is read from a `java.net.Socket` and then used to access a file and send it back over the socket. However, a malicious user could enter a file name anywhere on the file system, such as \"/etc/passwd\" or \"../../../etc/passwd\".\n\n\n```java\npublic void sendUserFile(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// BAD: read from a file without checking its path\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n\n```\nIf the input should only be a file name, you can check that it doesn't contain any path separators or \"..\" sequences.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\t// GOOD: ensure that the filename has no path separators or parent directory references\n\tif (filename.contains(\"..\") || filename.contains(\"/\") || filename.contains(\"\\\\\")) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filename));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\t\n}\n\n```\nIf the input should be within a specific directory, you can check that the resolved path is still contained within that directory.\n\n\n```java\npublic void sendUserFileGood(Socket sock, String user) {\n\tBufferedReader filenameReader = new BufferedReader(\n\t\t\tnew InputStreamReader(sock.getInputStream(), \"UTF-8\"));\n\tString filename = filenameReader.readLine();\n\n\tPath publicFolder = Paths.get(\"/home/\" + user + \"/public\").normalize().toAbsolutePath();\n\tPath filePath = publicFolder.resolve(filename).normalize().toAbsolutePath();\n\n\t// GOOD: ensure that the path stays within the public folder\n\tif (!filePath.startsWith(publicFolder + File.separator)) {\n\t\tthrow new IllegalArgumentException(\"Invalid filename\");\n\t}\n\tBufferedReader fileReader = new BufferedReader(new FileReader(filePath.toString()));\n\tString fileLine = fileReader.readLine();\n\twhile(fileLine != null) {\n\t\tsock.getOutputStream().write(fileLine.getBytes());\n\t\tfileLine = fileReader.readLine();\n\t}\n}\n```\n\n## References\n* OWASP: [Path Traversal](https://owasp.org/www-community/attacks/Path_Traversal).\n* Common Weakness Enumeration: [CWE-22](https://cwe.mitre.org/data/definitions/22.html).\n* Common Weakness Enumeration: [CWE-23](https://cwe.mitre.org/data/definitions/23.html).\n* Common Weakness Enumeration: [CWE-36](https://cwe.mitre.org/data/definitions/36.html).\n* Common Weakness Enumeration: [CWE-73](https://cwe.mitre.org/data/definitions/73.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/webwolf/FileServer.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/it/java/org/owasp/webgoat/integration/JWTLessonIntegrationTest.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTRefreshEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/jwt/JWTVotesEndpoint.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/test/java/org/owasp/webgoat/lessons/jwt/TokenTest.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/missing-jwt-signature-check",
        "severity": "7.8",
        "message": "This parser sets a [JWT signing key](1), but the signature is not verified.",
        "short_description": "Missing JWT signature check",
        "full_description": "Failing to check the Json Web Token (JWT) signature may allow an attacker to forge their own tokens.",
        "remediation": "# Missing JWT signature check\nA JSON Web Token (JWT) consists of three parts: header, payload, and signature. The `io.jsonwebtoken.jjwt` library is one of many libraries used for working with JWTs. It offers different methods for parsing tokens like `parse`, `parseClaimsJws`, and `parsePlaintextJws`. The last two correctly verify that the JWT is properly signed. This is done by computing the signature of the combination of header and payload and comparing the locally computed signature with the signature part of the JWT.\n\nTherefore it is necessary to provide the `JwtParser` with a key that is used for signature validation. Unfortunately the `parse` method **accepts** a JWT whose signature is empty although a signing key has been set for the parser. This means that an attacker can create arbitrary JWTs that will be accepted if this method is used.\n\n\n## Recommendation\nAlways verify the signature by using either the `parseClaimsJws` and `parsePlaintextJws` methods or by overriding the `onPlaintextJws` or `onClaimsJws` of `JwtHandlerAdapter`.\n\n\n## Example\nThe following example shows four cases where a signing key is set for a parser. In the first 'BAD' case the `parse` method is used, which will not validate the signature. The second 'BAD' case uses a `JwtHandlerAdapter` where the `onPlaintextJwt` method is overriden, so it will not validate the signature. The third and fourth 'GOOD' cases use `parseClaimsJws` method or override the `onPlaintextJws` method.\n\n\n```java\npublic void badJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(token); // BAD: Does not verify the signature\n}\n\npublic void badJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jwt<Header, String>>() {\n                    @Override\n                    public Jwt<Header, String> onPlaintextJwt(Jwt<Header, String> jwt) {\n                        return jwt;\n                    }\n                }); // BAD: The handler is called on an unverified JWT\n}\n\npublic void goodJwt(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parseClaimsJws(token) // GOOD: Verify the signature\n                .getBody();\n}\n\npublic void goodJwtHandler(String token) {\n    Jwts.parserBuilder()\n                .setSigningKey(\"someBase64EncodedKey\").build()\n                .parse(plaintextJwt, new JwtHandlerAdapter<Jws<String>>() {\n                    @Override\n                    public Jws<String> onPlaintextJws(Jws<String> jws) {\n                        return jws;\n                    }\n                }); // GOOD: The handler is called on a verified JWS\n}\n```\n\n## References\n* zofrex: [How I Found An alg=none JWT Vulnerability in the NHS Contact Tracing App](https://www.zofrex.com/blog/2020/10/20/alg-none-jwt-nhs-contact-tracing-app/).\n* Common Weakness Enumeration: [CWE-347](https://cwe.mitre.org/data/definitions/347.html).\n",
        "reference": "",
        "file": "src/test/java/org/owasp/webgoat/lessons/jwt/TokenTest.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/spring-disabled-csrf-protection",
        "severity": "8.8",
        "message": "CSRF vulnerability due to protection being disabled.",
        "short_description": "Disabled Spring CSRF protection",
        "full_description": "Disabling CSRF protection makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "remediation": "# Disabled Spring CSRF protection\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically, this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\n\n## Recommendation\nWhen you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by default. Spring's recommendation is to use CSRF protection for any request that could be processed by a browser client by normal users.\n\n\n## Example\nThe following example shows the Spring Java configuration with CSRF protection disabled. This type of configuration should only be used if you are creating a service that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n* OWASP: [Cross Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n* Spring Security Reference: [ Cross Site Request Forgery (CSRF) ](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/container/WebSecurityConfig.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/spring-disabled-csrf-protection",
        "severity": "8.8",
        "message": "CSRF vulnerability due to protection being disabled.",
        "short_description": "Disabled Spring CSRF protection",
        "full_description": "Disabling CSRF protection makes the application vulnerable to a Cross-Site Request Forgery (CSRF) attack.",
        "remediation": "# Disabled Spring CSRF protection\nCross-site request forgery (CSRF) is a type of vulnerability in which an attacker is able to force a user to carry out an action that the user did not intend.\n\nThe attacker tricks an authenticated user into submitting a request to the web application. Typically, this request will result in a state change on the server, such as changing the user's password. The request can be initiated when the user visits a site controlled by the attacker. If the web application relies only on cookies for authentication, or on other credentials that are automatically included in the request, then this request will appear as legitimate to the server.\n\n\n## Recommendation\nWhen you use Spring, Cross-Site Request Forgery (CSRF) protection is enabled by default. Spring's recommendation is to use CSRF protection for any request that could be processed by a browser client by normal users.\n\n\n## Example\nThe following example shows the Spring Java configuration with CSRF protection disabled. This type of configuration should only be used if you are creating a service that is used only by non-browser clients.\n\n\n```java\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\n\n@EnableWebSecurity\n@Configuration\npublic class WebSecurityConfig extends WebSecurityConfigurerAdapter {\n  @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http\n      .csrf(csrf ->\n        // BAD - CSRF protection shouldn't be disabled\n        csrf.disable() \n      );\n  }\n}\n\n```\n\n## References\n* OWASP: [Cross Site Request Forgery (CSRF)](https://www.owasp.org/index.php/Cross-Site_Request_Forgery_(CSRF)).\n* Spring Security Reference: [ Cross Site Request Forgery (CSRF) ](https://docs.spring.io/spring-security/reference/servlet/exploits/csrf.html).\n* Common Weakness Enumeration: [CWE-352](https://cwe.mitre.org/data/definitions/352.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/webwolf/WebSecurityConfig.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/polynomial-redos",
        "severity": "7.5",
        "message": "This [regular expression](1) that depends on a [user-provided value](2) may run slow on strings with many repetitions of ' '.\nThis [regular expression](3) that depends on a [user-provided value](2) may run slow on strings starting with 'union' and with many repetitions of 'union('.\nThis [regular expression](1) that depends on a [user-provided value](4) may run slow on strings with many repetitions of ' '.\nThis [regular expression](3) that depends on a [user-provided value](4) may run slow on strings starting with 'union' and with many repetitions of 'union('.\nThis [regular expression](1) that depends on a [user-provided value](5) may run slow on strings with many repetitions of ' '.\nThis [regular expression](3) that depends on a [user-provided value](5) may run slow on strings starting with 'union' and with many repetitions of 'union('.",
        "short_description": "Polynomial regular expression used on uncontrolled data",
        "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "remediation": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/advanced/SqlInjectionLesson6a.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/polynomial-redos",
        "severity": "7.5",
        "message": "This [regular expression](1) that depends on a [user-provided value](2) may run slow on strings starting with '<' and with many repetitions of '<'.",
        "short_description": "Polynomial regular expression used on uncontrolled data",
        "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "remediation": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/sqlinjection/mitigation/SqlInjectionLesson10b.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/polynomial-redos",
        "severity": "7.5",
        "message": "This [regular expression](1) that depends on a [user-provided value](2) may run slow on strings starting with '<script>alert(' and with many repetitions of '<script>alert('.\nThis [regular expression](3) that depends on a [user-provided value](2) may run slow on strings starting with '<script>alert()</script>' and with many repetitions of ')</script>'.",
        "short_description": "Polynomial regular expression used on uncontrolled data",
        "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "remediation": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/polynomial-redos",
        "severity": "7.5",
        "message": "This [regular expression](1) that depends on a [user-provided value](2) may run slow on strings starting with '<script>alert(' and with many repetitions of '<script>alert('.\nThis [regular expression](3) that depends on a [user-provided value](2) may run slow on strings starting with '<script>alert()</script>' and with many repetitions of ')</script>'.",
        "short_description": "Polynomial regular expression used on uncontrolled data",
        "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "remediation": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xss/CrossSiteScriptingLesson5a.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/polynomial-redos",
        "severity": "7.5",
        "message": "This [regular expression](1) that depends on a [user-provided value](2) may run slow on strings starting with '<' and with many repetitions of '<'.",
        "short_description": "Polynomial regular expression used on uncontrolled data",
        "full_description": "A regular expression that can require polynomial time to match may be vulnerable to denial-of-service attacks.",
        "remediation": "# Polynomial regular expression used on uncontrolled data\nSome regular expressions take a long time to match certain input strings to the point where the time it takes to match a string of length *n* is proportional to *n<sup>k</sup>* or even *2<sup>n</sup>*. Such regular expressions can negatively affect performance, or even allow a malicious user to perform a Denial of Service (\"DoS\") attack by crafting an expensive input string for the regular expression to match.\n\nThe regular expression engine provided by Java uses a backtracking non-deterministic finite automata to implement regular expression matching. While this approach is space-efficient and allows supporting advanced features like capture groups, it is not time-efficient in general. The worst-case time complexity of such an automaton can be polynomial or even exponential, meaning that for strings of a certain shape, increasing the input length by ten characters may make the automaton about 1000 times slower.\n\nTypically, a regular expression is affected by this problem if it contains a repetition of the form `r*` or `r+` where the sub-expression `r` is ambiguous in the sense that it can match some string in multiple ways. More information about the precise circumstances can be found in the references.\n\nNote that Java versions 9 and above have some mitigations against ReDoS; however they aren't perfect and more complex regular expressions can still be affected by this problem.\n\n\n## Recommendation\nModify the regular expression to remove the ambiguity, or ensure that the strings matched with the regular expression are short enough that the time-complexity does not matter. Alternatively, an alternate regex library that guarantees linear time execution, such as Google's RE2J, may be used.\n\n\n## Example\nConsider this use of a regular expression, which removes all leading and trailing whitespace in a string:\n\n```java\n\nPattern.compile(\"^\\\\s+|\\\\s+$\").matcher(text).replaceAll(\"\") // BAD\n```\nThe sub-expression `\"\\\\s+$\"` will match the whitespace characters in `text` from left to right, but it can start matching anywhere within a whitespace sequence. This is problematic for strings that do **not** end with a whitespace character. Such a string will force the regular expression engine to process each whitespace sequence once per whitespace character in the sequence.\n\nThis ultimately means that the time cost of trimming a string is quadratic in the length of the string. So a string like `\"a b\"` will take milliseconds to process, but a similar string with a million spaces instead of just one will take several minutes.\n\nAvoid this problem by rewriting the regular expression to not contain the ambiguity about when to start matching whitespace sequences. For instance, by using a negative look-behind (`\"^\\\\s+|(?<!\\\\s)\\\\s+$\"`), or just by using the built-in trim method (`text.trim()`).\n\nNote that the sub-expression `\"^\\\\s+\"` is **not** problematic as the `^` anchor restricts when that sub-expression can start matching, and as the regular expression engine matches from left to right.\n\n\n## Example\nAs a similar, but slightly subtler problem, consider the regular expression that matches lines with numbers, possibly written using scientific notation:\n\n```java\n\n\"^0\\\\.\\\\d+E?\\\\d+$\"\" \n```\nThe problem with this regular expression is in the sub-expression `\\d+E?\\d+` because the second `\\d+` can start matching digits anywhere after the first match of the first `\\d+` if there is no `E` in the input string.\n\nThis is problematic for strings that do **not** end with a digit. Such a string will force the regular expression engine to process each digit sequence once per digit in the sequence, again leading to a quadratic time complexity.\n\nTo make the processing faster, the regular expression should be rewritten such that the two `\\d+` sub-expressions do not have overlapping matches: `\"^0\\\\.\\\\d+(E\\\\d+)?$\"`.\n\n\n## Example\nSometimes it is unclear how a regular expression can be rewritten to avoid the problem. In such cases, it often suffices to limit the length of the input string. For instance, the following regular expression is used to match numbers, and on some non-number inputs it can have quadratic time complexity:\n\n```java\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\nIt is not immediately obvious how to rewrite this regular expression to avoid the problem. However, you can mitigate performance issues by limiting the length to 1000 characters, which will always finish in a reasonable amount of time.\n\n```java\n\nif (str.length() > 1000) {\n    throw new IllegalArgumentException(\"Input too long\");\n}\n\nPattern.matches(\"^(\\\\+|-)?(\\\\d+|(\\\\d*\\\\.\\\\d*))?(E|e)?([-+])?(\\\\d+)?$\", str); \n```\n\n## References\n* OWASP: [Regular expression Denial of Service - ReDoS](https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS).\n* Wikipedia: [ReDoS](https://en.wikipedia.org/wiki/ReDoS).\n* Wikipedia: [Time complexity](https://en.wikipedia.org/wiki/Time_complexity).\n* James Kirrage, Asiri Rathnayake, Hayo Thielecke: [Static Analysis for Regular Expression Denial-of-Service Attack](https://arxiv.org/abs/1301.0849).\n* Common Weakness Enumeration: [CWE-1333](https://cwe.mitre.org/data/definitions/1333.html).\n* Common Weakness Enumeration: [CWE-730](https://cwe.mitre.org/data/definitions/730.html).\n* Common Weakness Enumeration: [CWE-400](https://cwe.mitre.org/data/definitions/400.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xss/mitigation/CrossSiteScriptingLesson4.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/unsafe-deserialization",
        "severity": "9.8",
        "message": "Unsafe deserialization depends on a [user-provided value](1).",
        "short_description": "Deserialization of user-controlled data",
        "full_description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "remediation": "# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.\n\nAlternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.\n\nRecommendations specific to particular frameworks supported by this query:\n\n**FastJson** - `com.alibaba:fastjson`\n\n* **Secure by Default**: Partially\n* **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.\n\n\n**FasterXML** - `com.fasterxml.jackson.core:jackson-databind`\n\n* **Secure by Default**: Yes\n* **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).\n\n\n**Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`\n\n* **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0\n* **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.\n\n\n**ObjectInputStream** - `Java Standard Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.\n\n\n**SnakeYAML** - `org.yaml:snakeyaml`\n\n* **Secure by Default**: As of version 2.0.\n* **Recommendation**: For versions before 2.0, pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.\n\n\n**XML Decoder** - `Standard Java Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Do not use with untrusted user input.\n\n\n**ObjectMesssage** - `Java EE/Jakarta EE`\n\n* **Secure by Default**: Depends on the JMS implementation.\n* **Recommendation**: Do not use with untrusted user input.\n\n\n\n## Example\nThe following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic MyObject {\n  public int field;\n  MyObject(int field) {\n    this.field = field;\n  }\n}\n\npublic MyObject deserialize(Socket sock) {\n  try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {\n    return (MyObject)in.readObject(); // BAD: in is from untrusted source\n  }\n}\n\n```\nRewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.\n\n\n```java\npublic MyObject deserialize(Socket sock) {\n  try(DataInputStream in = new DataInputStream(sock.getInputStream())) {\n    return new MyObject(in.readInt()); // GOOD: read only an int\n  }\n}\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).\n* Alvaro Mu\u00f1oz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).\n* SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml) (not updated for new behaviour in version 2.0).\n* Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).\n* Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).\n* Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).\n* JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).\n* Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)\n* Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don\u2019t Panic \u2014 Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)\n* Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).\n* Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).\n* RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).\n* Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).\n* Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/deserialization/InsecureDeserializationTask.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/unsafe-deserialization",
        "severity": "9.8",
        "message": "Unsafe deserialization depends on a [user-provided value](1).",
        "short_description": "Deserialization of user-controlled data",
        "full_description": "Deserializing user-controlled data may allow attackers to execute arbitrary code.",
        "remediation": "# Deserialization of user-controlled data\nDeserializing untrusted data using any deserialization framework that allows the construction of arbitrary serializable objects is easily exploitable and in many cases allows an attacker to execute arbitrary code. Even before a deserialized object is returned to the caller of a deserialization method a lot of code may have been executed, including static initializers, constructors, and finalizers. Automatic deserialization of fields means that an attacker may craft a nested combination of objects on which the executed initialization code may have unforeseen effects, such as the execution of arbitrary code.\n\nThere are many different serialization frameworks. This query currently supports Kryo, XmlDecoder, XStream, SnakeYaml, JYaml, JsonIO, YAMLBeans, HessianBurlap, Castor, Burlap, Jackson, Jabsorb, Jodd JSON, Flexjson, Gson, JMS, and Java IO serialization through `ObjectInputStream`/`ObjectOutputStream`.\n\n\n## Recommendation\nAvoid deserialization of untrusted data if at all possible. If the architecture permits it then use other formats instead of serialized objects, for example JSON or XML. However, these formats should not be deserialized into complex objects because this provides further opportunities for attack. For example, XML-based deserialization attacks are possible through libraries such as XStream and XmlDecoder.\n\nAlternatively, a tightly controlled whitelist can limit the vulnerability of code, but be aware of the existence of so-called Bypass Gadgets, which can circumvent such protection measures.\n\nRecommendations specific to particular frameworks supported by this query:\n\n**FastJson** - `com.alibaba:fastjson`\n\n* **Secure by Default**: Partially\n* **Recommendation**: Call `com.alibaba.fastjson.parser.ParserConfig#setSafeMode` with the argument `true` before deserializing untrusted data.\n\n\n**FasterXML** - `com.fasterxml.jackson.core:jackson-databind`\n\n* **Secure by Default**: Yes\n* **Recommendation**: Don't call `com.fasterxml.jackson.databind.ObjectMapper#enableDefaultTyping` and don't annotate any object fields with `com.fasterxml.jackson.annotation.JsonTypeInfo` passing either the `CLASS` or `MINIMAL_CLASS` values to the annotation. Read [this guide](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba).\n\n\n**Kryo** - `com.esotericsoftware:kryo` and `com.esotericsoftware:kryo5`\n\n* **Secure by Default**: Yes for `com.esotericsoftware:kryo5` and for `com.esotericsoftware:kryo` &gt;= v5.0.0\n* **Recommendation**: Don't call `com.esotericsoftware.kryo(5).Kryo#setRegistrationRequired` with the argument `false` on any `Kryo` instance that may deserialize untrusted data.\n\n\n**ObjectInputStream** - `Java Standard Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Use a validating input stream, such as `org.apache.commons.io.serialization.ValidatingObjectInputStream`.\n\n\n**SnakeYAML** - `org.yaml:snakeyaml`\n\n* **Secure by Default**: As of version 2.0.\n* **Recommendation**: For versions before 2.0, pass an instance of `org.yaml.snakeyaml.constructor.SafeConstructor` to `org.yaml.snakeyaml.Yaml`'s constructor before using it to deserialize untrusted data.\n\n\n**XML Decoder** - `Standard Java Library`\n\n* **Secure by Default**: No\n* **Recommendation**: Do not use with untrusted user input.\n\n\n**ObjectMesssage** - `Java EE/Jakarta EE`\n\n* **Secure by Default**: Depends on the JMS implementation.\n* **Recommendation**: Do not use with untrusted user input.\n\n\n\n## Example\nThe following example calls `readObject` directly on an `ObjectInputStream` that is constructed from untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic MyObject {\n  public int field;\n  MyObject(int field) {\n    this.field = field;\n  }\n}\n\npublic MyObject deserialize(Socket sock) {\n  try(ObjectInputStream in = new ObjectInputStream(sock.getInputStream())) {\n    return (MyObject)in.readObject(); // BAD: in is from untrusted source\n  }\n}\n\n```\nRewriting the communication protocol to only rely on reading primitive types from the input stream removes the vulnerability.\n\n\n```java\npublic MyObject deserialize(Socket sock) {\n  try(DataInputStream in = new DataInputStream(sock.getInputStream())) {\n    return new MyObject(in.readInt()); // GOOD: read only an int\n  }\n}\n\n```\n\n## References\n* OWASP vulnerability description: [Deserialization of untrusted data](https://www.owasp.org/index.php/Deserialization_of_untrusted_data).\n* OWASP guidance on deserializing objects: [Deserialization Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Deserialization_Cheat_Sheet.html).\n* Talks by Chris Frohoff &amp; Gabriel Lawrence: [ AppSecCali 2015: Marshalling Pickles - how deserializing objects will ruin your day](http://frohoff.github.io/appseccali-marshalling-pickles/), [OWASP SD: Deserialize My Shorts: Or How I Learned to Start Worrying and Hate Java Object Deserialization](http://frohoff.github.io/owaspsd-deserialize-my-shorts/).\n* Alvaro Mu\u00f1oz &amp; Christian Schneider, RSAConference 2016: [Serial Killer: Silently Pwning Your Java Endpoints](https://speakerdeck.com/pwntester/serial-killer-silently-pwning-your-java-endpoints).\n* SnakeYaml documentation on deserialization: [SnakeYaml deserialization](https://bitbucket.org/snakeyaml/snakeyaml/wiki/Documentation#markdown-header-loading-yaml) (not updated for new behaviour in version 2.0).\n* Hessian deserialization and related gadget chains: [Hessian deserialization](https://paper.seebug.org/1137/).\n* Castor and Hessian java deserialization vulnerabilities: [Castor and Hessian deserialization](https://securitylab.github.com/research/hessian-java-deserialization-castor-vulnerabilities/).\n* Remote code execution in JYaml library: [JYaml deserialization](https://www.cybersecurity-help.cz/vdb/SB2020022512).\n* JsonIO deserialization vulnerabilities: [JsonIO deserialization](https://klezvirus.github.io/Advanced-Web-Hacking/Serialisation/).\n* Research by Moritz Bechler: [Java Unmarshaller Security - Turning your data into code execution](https://www.github.com/mbechler/marshalsec/blob/master/marshalsec.pdf?raw=true)\n* Blog posts by the developer of Jackson libraries: [On Jackson CVEs: Don\u2019t Panic \u2014 Here is what you need to know](https://cowtowncoder.medium.com/on-jackson-cves-dont-panic-here-is-what-you-need-to-know-54cd0d6e8062) [Jackson 2.10: Safe Default Typing](https://cowtowncoder.medium.com/jackson-2-10-safe-default-typing-2d018f0ce2ba)\n* Jabsorb documentation on deserialization: [Jabsorb JSON Serializer](https://github.com/Servoy/jabsorb/blob/master/src/org/jabsorb/).\n* Jodd JSON documentation on deserialization: [JoddJson Parser](https://json.jodd.org/parser).\n* RCE in Flexjson: [Flexjson deserialization](https://codewhitesec.blogspot.com/2020/03/liferay-portal-json-vulns.html).\n* Android Intent deserialization vulnerabilities with GSON parser: [Insecure use of JSON parsers](https://blog.oversecured.com/Exploiting-memory-corruption-vulnerabilities-on-Android/#insecure-use-of-json-parsers).\n* Research by Matthias Kaiser: [Pwning Your Java Messaging With Deserialization Vulnerabilities](https://www.blackhat.com/docs/us-16/materials/us-16-Kaiser-Pwning-Your-Java-Messaging-With-Deserialization-Vulnerabilities.pdf).\n* Common Weakness Enumeration: [CWE-502](https://cwe.mitre.org/data/definitions/502.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/vulnerablecomponents/VulnerableComponentsLesson.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/ssrf",
        "severity": "9.1",
        "message": "Potential server-side request forgery due to a [user-provided value](1).",
        "short_description": "Server-side request forgery",
        "full_description": "Making web requests based on unvalidated user-input may cause the server to communicate with malicious servers.",
        "remediation": "# Server-side request forgery\nDirectly incorporating user input into an HTTP request without validating the input can facilitate server-side request forgery (SSRF) attacks. In these attacks, the server may be tricked into making a request and interacting with an attacker-controlled server.\n\n\n## Recommendation\nTo guard against SSRF attacks, you should avoid putting user-provided input directly into a request URL. Instead, maintain a list of authorized URLs on the server; then choose from that list based on the input provided. Alternatively, ensure requests constructed from user input are limited to a particular host or more restrictive URL prefix.\n\n\n## Example\nThe following example shows an HTTP request parameter being used directly to form a new request without validating the input, which facilitates SSRF attacks. It also shows how to remedy the problem by validating the user input against a known fixed string.\n\n\n```java\nimport java.net.http.HttpClient;\n\npublic class SSRF extends HttpServlet {\n\tprivate static final String VALID_URI = \"http://lgtm.com\";\n\tprivate HttpClient client = HttpClient.newHttpClient();\n\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response)\n\t\tthrows ServletException, IOException {\n\t\tURI uri = new URI(request.getParameter(\"uri\"));\n\t\t// BAD: a request parameter is incorporated without validation into a Http request\n\t\tHttpRequest r = HttpRequest.newBuilder(uri).build();\n\t\tclient.send(r, null);\n\n\t\t// GOOD: the request parameter is validated against a known fixed string\n\t\tif (VALID_URI.equals(request.getParameter(\"uri\"))) {\n\t\t\tHttpRequest r2 = HttpRequest.newBuilder(uri).build();\n\t\t\tclient.send(r2, null);\n\t\t}\n\t}\n}\n\n```\n\n## References\n* [OWASP SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)\n* Common Weakness Enumeration: [CWE-918](https://cwe.mitre.org/data/definitions/918.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/ssrf/SSRFTask2.java"
      },
      {
        "tool": "CodeQL",
        "type": "SAST-java",
        "rule_id": "java/xxe",
        "severity": "9.1",
        "message": "XML parsing depends on a [user-provided value](1) without guarding against external entity expansion.\nXML parsing depends on a [user-provided value](2) without guarding against external entity expansion.\nXML parsing depends on a [user-provided value](3) without guarding against external entity expansion.",
        "short_description": "Resolving XML external entity in user-controlled data",
        "full_description": "Parsing user-controlled XML documents and allowing expansion of external entity references may lead to disclosure of confidential data or denial of service.",
        "remediation": "# Resolving XML external entity in user-controlled data\nParsing untrusted XML files with a weakly configured XML parser may lead to an XML External Entity (XXE) attack. This type of attack uses external entity references to access arbitrary files on a system, carry out denial of service, or server side request forgery. Even when the result of parsing is not returned to the user, out-of-band data retrieval techniques may allow attackers to steal sensitive data. Denial of services can also be carried out in this situation.\n\nThere are many XML parsers for Java, and most of them are vulnerable to XXE because their default settings enable parsing of external entities. This query currently identifies vulnerable XML parsing from the following parsers: `javax.xml.parsers.DocumentBuilder`, `javax.xml.stream.XMLStreamReader`, `org.jdom.input.SAXBuilder`/`org.jdom2.input.SAXBuilder`, `javax.xml.parsers.SAXParser`,`org.dom4j.io.SAXReader`, `org.xml.sax.XMLReader`, `javax.xml.transform.sax.SAXSource`, `javax.xml.transform.TransformerFactory`, `javax.xml.transform.sax.SAXTransformerFactory`, `javax.xml.validation.SchemaFactory`, `javax.xml.bind.Unmarshaller` and `javax.xml.xpath.XPathExpression`.\n\n\n## Recommendation\nThe best way to prevent XXE attacks is to disable the parsing of any Document Type Declarations (DTDs) in untrusted data. If this is not possible you should disable the parsing of external general entities and external parameter entities. This improves security but the code will still be at risk of denial of service and server side request forgery attacks. Protection against denial of service attacks may also be implemented by setting entity expansion limits, which is done by default in recent JDK and JRE implementations. We recommend visiting OWASP's [XML Entity Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java), finding the specific XML parser, and applying the mitigation listed there. Other mitigations might be sufficient in some cases, but manual verification will be needed, as the query will continue to flag the parser as potentially dangerous.\n\n\n## Example\nThe following example calls `parse` on a `DocumentBuilder` that is not safely configured on untrusted data, and is therefore inherently unsafe.\n\n\n```java\npublic void parse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); // BAD: DTD parsing is enabled\n}\n\n```\nIn this example, the `DocumentBuilder` is created with DTD disabled, securing it against XXE attack.\n\n\n```java\npublic void disableDTDParse(Socket sock) throws Exception {\n  DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n  factory.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n  DocumentBuilder builder = factory.newDocumentBuilder();\n  builder.parse(sock.getInputStream()); // GOOD: DTD parsing is disabled\n}\n\n```\n\n## References\n* OWASP vulnerability description: [XML External Entity (XXE) Processing](https://www.owasp.org/index.php/XML_External_Entity_(XXE)_Processing).\n* OWASP guidance on parsing xml files: [XXE Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#java).\n* Paper by Timothy Morgen: [XML Schema, DTD, and Entity Attacks](https://research.nccgroup.com/2014/05/19/xml-schema-dtd-and-entity-attacks-a-compendium-of-known-techniques/)\n* Out-of-band data retrieval: Timur Yunusov &amp; Alexey Osipov, Black hat EU 2013: [XML Out-Of-Band Data Retrieval](https://www.slideshare.net/qqlan/bh-ready-v4).\n* Denial of service attack (Billion laughs): [Billion Laughs.](https://en.wikipedia.org/wiki/Billion_laughs)\n* The Java Tutorials: [Processing Limit Definitions.](https://docs.oracle.com/javase/tutorial/jaxp/limits/limits.html)\n* Common Weakness Enumeration: [CWE-611](https://cwe.mitre.org/data/definitions/611.html).\n* Common Weakness Enumeration: [CWE-776](https://cwe.mitre.org/data/definitions/776.html).\n* Common Weakness Enumeration: [CWE-827](https://cwe.mitre.org/data/definitions/827.html).\n",
        "reference": "",
        "file": "src/main/java/org/owasp/webgoat/lessons/xxe/CommentsCache.java"
      }
    ]
  },
  {
    "tool": "Trivy",
    "type": "SCA File Scan",
    "timestamp": "2025-10-21T07:37:59.988420+00:00",
    "target": "file:///home/runner/work/WebGoat-T/WebGoat-T/",
    "results": [
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-53864",
        "component": "com.nimbusds:nimbus-jose-jwt",
        "severity": "5.8",
        "description": "com.nimbusds/nimbus-jose-jwt: Uncontrolled recursion in Connect2id Nimbus JOSE + JWT",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-53864"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2013-7285",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "9.8",
        "description": "XStream: remote code execution due to insecure XML deserialization",
        "remediation": "Xstream API versions up to 1.4.6 and version 1.4.10, if the security framework has not been initialized, may allow a remote attacker to run arbitrary shell commands by manipulating the processed input stream when unmarshaling XML or any supported format. e.g. JSON.",
        "reference": "https://avd.aquasec.com/nvd/cve-2013-7285"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2019-10173",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "9.8",
        "description": "xstream: remote code execution due to insecure XML deserialization (regression of  CVE-2013-7285)",
        "remediation": "It was found that xstream API version 1.4.10 before 1.4.11 introduced a regression for a previous deserialization flaw. If the security framework has not been initialized, it may allow a remote attacker to run arbitrary shell commands when unmarshalling XML or any supported format. e.g. JSON. (regression of CVE-2013-7285)",
        "reference": "https://avd.aquasec.com/nvd/cve-2019-10173"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2016-3674",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: enabled processing of external entities",
        "remediation": "Multiple XML external entity (XXE) vulnerabilities in the (1) Dom4JDriver, (2) DomDriver, (3) JDomDriver, (4) JDom2Driver, (5) SjsxpDriver, (6) StandardStaxDriver, and (7) WstxDriver drivers in XStream before 1.4.9 allow remote attackers to read arbitrary files via a crafted XML document.",
        "reference": "https://avd.aquasec.com/nvd/cve-2016-3674"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2017-7957",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: DoS when unmarshalling void type",
        "remediation": "XStream through 1.4.9, when a certain denyTypes workaround is not used, mishandles attempts to create an instance of the primitive type 'void' during unmarshalling, leading to a remote application crash, as demonstrated by an xstream.fromXML(\"<void/>\") call.",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-7957"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2020-26217",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.1",
        "description": "XStream: remote code execution due to insecure XML deserialization when relying on blocklists",
        "remediation": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14.",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26217"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21341",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: allow a remote attacker to cause DoS only by manipulating the processed input stream",
        "remediation": "XStream is a Java library to serialize objects to XML and back again. In XStream before version 1.4.16, there is vulnerability which may allow a remote attacker to allocate 100% CPU time on the target system depending on CPU type or parallel execution of such a payload resulting in a denial of service only by manipulating the processed input stream. No user is affected who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the Security Framework, you will have to use at least version 1.4.16.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21341"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-29505",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: remote command execution attack by manipulating the processed input stream",
        "remediation": "XStream is software for serializing Java objects to XML and back again. A vulnerability in XStream versions prior to 1.4.17 may allow a remote attacker has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types is affected. The vulnerability is patched in version 1.4.17.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-29505"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39139",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of Xalan xsltc.trax.TemplatesImpl",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. A user is only affected if using the version out of the box with JDK 1.7u21 or below. However, this scenario can be adjusted easily to an external Xalan that works regardless of the version of the Java runtime. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39139"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39141",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.xml.internal.ws.client.sei.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39141"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39144",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of sun.tracing.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39144"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39145",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapBindingEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39145"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39146",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of javax.swing.UIDefaults$ProxyLazyValue",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39146"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39147",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapSearchEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39147"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39148",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.toolkit.dir.ContextEnumerator",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39148"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39149",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.corba.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39149"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39150",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Server-side request forgery (SSRF) via unsafe deserialization of com.sun.xml.internal.ws.client.sei.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to request data from internal resources that are not publicly available only by manipulating the processed input stream with a Java runtime version 14 to 8. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the [Security Framework](https://x-stream.github.io/security.html#framework), you will have to use at least version 1.4.18.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39150"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39151",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapBindingEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39151"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39152",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Server-side request forgery (SSRF) via unsafe deserialization of jdk.nashorn.internal.runtime.Source$URLData",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to request data from internal resources that are not publicly available only by manipulating the processed input stream with a Java runtime version 14 to 8. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the [Security Framework](https://x-stream.github.io/security.html#framework), you will have to use at least version 1.4.18.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39152"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39153",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of Xalan xsltc.trax.TemplatesImpl",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream, if using the version out of the box with Java runtime version 14 to 8 or with JavaFX installed. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39153"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39154",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of javax.swing.UIDefaults$ProxyLazyValue",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39154"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-43859",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "xstream: Injecting highly recursive collections or maps can cause a DoS",
        "remediation": "XStream is an open source java library to serialize objects to XML and back again. Versions prior to 1.4.19 may allow a remote attacker to allocate 100% CPU time on the target system depending on CPU type or parallel execution of such a payload resulting in a denial of service only by manipulating the processed input stream. XStream 1.4.19 monitors and accumulates the time it takes to add elements to collections and throws an exception if a set threshold is exceeded. Users are advised to upgrade as soon as possible. Users unable to upgrade may set the NO_REFERENCE mode to prevent recursion. See GHSA-rmr5-cpv2-vgjf for further details on a workaround if an upgrade is not possible.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-43859"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2022-40151",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "xstream: Xstream to serialise XML data was vulnerable to Denial of Service attacks",
        "remediation": "Those using Xstream to seralize XML data may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow. This effect may support a denial of service attack.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-40151"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2022-41966",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.2",
        "description": "xstream: Denial of Service by injecting recursive collections or maps based on element&#39;s hash values raising a stack overflow",
        "remediation": "XStream serializes Java objects to XML and back again. Versions prior to 1.4.20 may allow a remote attacker to terminate the application with a stack overflow error, resulting in a denial of service only via manipulation the processed input stream. The attack uses the hash code implementation for collections and maps to force recursive hash calculation causing a stack overflow. This issue is patched in version 1.4.20 which handles the stack overflow and raises an InputManipulationException instead. A potential workaround for users who only use HashMap or HashSet and whose XML refers these only as default map or set, is to change the default implementation of java.util.Map and java.util per the code example in the referenced advisory. However, this implies that your application does not care about the implementation of the map and all elements are comparable.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-41966"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2024-47072",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "com.thoughtworks.xstream: XStream is vulnerable to a Denial of Service attack due to stack overflow from a manipulated binary input stream",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. This vulnerability may allow a remote attacker to terminate the application with a stack overflow error resulting in a denial of service only by manipulating the processed input stream when XStream is configured to use the BinaryStreamDriver. XStream 1.4.21 has been patched to detect the manipulation in the binary input stream causing the the stack overflow and raises an InputManipulationException instead. Users are advised to upgrade. Users unable to upgrade may catch the StackOverflowError in the client code calling XStream if XStream is configured to use the BinaryStreamDriver.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-47072"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2020-26258",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.3",
        "description": "XStream: Server-Side Forgery Request vulnerability can be activated when unmarshalling",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26258"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2020-26259",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.8",
        "description": "XStream: arbitrary file deletion on the local host when unmarshalling",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26259"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21342",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: SSRF via crafted input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21342"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21343",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: arbitrary file deletion on the local host via crafted input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21343"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21344",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: Unsafe deserizaliation of javax.sql.rowset.BaseRowSet",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21344"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21345",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.8",
        "description": "XStream: Unsafe deserizaliation of com.sun.corba.se.impl.activation.ServerTableEntry",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21345"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21346",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: Unsafe deserizaliation of sun.swing.SwingLazyValue",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21346"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21347",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: Unsafe deserizaliation of com.sun.tools.javac.processing.JavacProcessingEnvironment NameProcessIterator",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21347"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21348",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: ReDoS vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21348"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21349",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: SSRF can be activated unmarshalling with XStream to access data streams from an arbitrary URL referencing a resource in an intranet or the local host",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21349"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21350",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: Unsafe deserizaliation of com.sun.org.apache.bcel.internal.util.ClassLoader",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21350"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-21351",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.4",
        "description": "XStream: allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21351"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2021-39140",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.5",
        "description": "xstream: Infinite loop DoS via unsafe deserialization of sun.reflect.annotation.AnnotationInvocationHandler",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39140"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-48924",
        "component": "org.apache.commons:commons-lang3",
        "severity": "6.5",
        "description": "commons-lang/commons-lang: org.apache.commons/commons-lang3: Uncontrolled Recursion vulnerability in Apache Commons Lang",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48924"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-48988",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "7.5",
        "description": "tomcat: Apache Tomcat DoS in multipart upload",
        "remediation": "Users are recommended to upgrade to version 11.0.8, 10.1.42 or 9.0.106, which fix the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48988"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-48989",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "7.5",
        "description": "tomcat: http/2 &#34;MadeYouReset&#34; DoS attack through HTTP/2 control frames",
        "remediation": "Users are recommended to upgrade to one of versions 11.0.10, 10.1.44 or 9.0.108 which fix the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48989"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-31650",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "5.5",
        "description": "tomcat: Apache Tomcat: DoS via malformed HTTP/2 PRIORITY_UPDATE frame",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-31650"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-49125",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "5.5",
        "description": "tomcat: Apache Tomcat: Security constraint bypass for pre/post-resources",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-49125"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-31651",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "2.0",
        "description": "tomcat: Apache Tomcat: Bypass of rules in Rewrite Valve",
        "remediation": "Users are recommended to upgrade to version [FIXED_VERSION], which fixes the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-31651"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-46701",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "2.0",
        "description": "tomcat: Apache Tomcat: Security constraint bypass for CGI scripts",
        "remediation": "Users are recommended to upgrade to version 11.0.7, 10.1.41 or 9.0.105, which fixes the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-46701"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2023-51775",
        "component": "org.bitbucket.b_c:jose4j",
        "severity": "6.5",
        "description": "jose4j: denial of service via specially crafted JWE",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2023-51775"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-46551",
        "component": "org.jruby:jruby",
        "severity": "5.5",
        "description": "jruby-openssl: jruby: JRuby-OpenSSL has hostname verification disabled by default",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-46551"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-22235",
        "component": "org.springframework.boot:spring-boot",
        "severity": "7.3",
        "description": "org.springframework.boot/spring-boot: Spring Boot EndpointRequest.to() creates wrong matcher if actuator endpoint is not exposed",
        "remediation": "*  Your application does not handle requests to /null\u00a0or this path does not need protection",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-22235"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-41232",
        "component": "org.springframework.security:spring-security-core",
        "severity": "9.1",
        "description": "Spring-Security: Spring Security authorization bypass for method security annotations on private methods",
        "remediation": "*  You have no Spring Security-annotated private methods",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41232"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-41248",
        "component": "org.springframework.security:spring-security-core",
        "severity": "7.5",
        "description": "org.springframework.security/spring-security-core: Spring Security authorization bypass",
        "remediation": "This CVE is published in conjunction with  CVE-2025-41249 https://spring.io/security/cve-2025-41249 .",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41248"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-22233",
        "component": "org.springframework:spring-context",
        "severity": "3.1",
        "description": "CVE-2024-38820 ensured Locale-independent, lowercase conversion for bo ...",
        "remediation": "This issue was responsibly reported by the TERASOLUNA Framework Development Team from NTT DATA Group Corporation.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-22233"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-41249",
        "component": "org.springframework:spring-core",
        "severity": "7.5",
        "description": "org.springframework/spring-core: Spring Framework Annotation Detection Vulnerability",
        "remediation": "This CVE is published in conjunction with  CVE-2025-41248 https://spring.io/security/cve-2025-41248 .",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41249"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-41234",
        "component": "org.springframework:spring-web",
        "severity": "6.5",
        "description": "springframework: Reflected download attack in Spring Framework with non-ASCII headers",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41234"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "CVE-2025-41242",
        "component": "org.springframework:spring-webmvc",
        "severity": "5.9",
        "description": "org.springframework/spring-webmvc: Spring Framework MVC path traversal vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41242"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      },
      {
        "tool": "Trivy",
        "type": "SCA File Scan",
        "cve": "jwt-token",
        "component": "Secret JWT token",
        "severity": "5.5",
        "description": "JWT token",
        "remediation": "",
        "reference": "https://github.com/aquasecurity/trivy/blob/main/pkg/fanal/secret/builtin-rules.go"
      }
    ]
  },
  {
    "tool": "Trivy",
    "type": "SCA Image Scan",
    "timestamp": "2025-10-21T07:37:59.991998+00:00",
    "target": "file:///",
    "results": [
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2016-2781",
        "component": "coreutils",
        "severity": "2.0",
        "description": "coreutils: Non-privileged session can escape to the parent session in chroot",
        "remediation": "chroot in GNU coreutils, when used with --userspec, allows local users to escape to the parent session via a crafted TIOCSTI ioctl call, which pushes characters to the terminal's input buffer.",
        "reference": "https://avd.aquasec.com/nvd/cve-2016-2781"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6297",
        "component": "dpkg",
        "severity": "2.0",
        "description": "It was discovered that dpkg-deb does not properly sanitize directory p ...",
        "remediation": "exhaustion or disk full conditions.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6297"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-30258",
        "component": "keyboxd",
        "severity": "5.5",
        "description": "gnupg: verification DoS due to a malicious subkey in the keyring",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-30258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-3219",
        "component": "keyboxd",
        "severity": "2.0",
        "description": "gnupg: denial of service issue (resource consumption) using compressed packets",
        "remediation": "GnuPG can be made to spin on a relatively small input by (for example) crafting a public key with thousands of signatures attached, compressed down to just a few KB.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-3219"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0395",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: buffer overflow in the GNU C Library&#39;s assert()",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0395"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5702",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Vector register overwrite bug in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5702"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8058",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Double free in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8058"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0395",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: buffer overflow in the GNU C Library&#39;s assert()",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0395"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5702",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Vector register overwrite bug in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5702"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8058",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Double free in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8058"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1390",
        "component": "libcap2",
        "severity": "5.5",
        "description": "libcap: pam_cap: Fix potential configuration parsing error",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1390"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-8176",
        "component": "libexpat1",
        "severity": "5.5",
        "description": "libexpat: expat: Improper Restriction of XML Entity Expansion Depth in libexpat",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-8176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-2236",
        "component": "libgcrypt20",
        "severity": "2.0",
        "description": "libgcrypt: vulnerable to Marvin Attack",
        "remediation": "A timing-based side-channel flaw was found in libgcrypt's RSA implementation. This issue may allow a remote attacker to initiate a Bleichenbacher-style attack, which can lead to the decryption of RSA ciphertexts.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-2236"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-12243",
        "component": "libgnutls30t64",
        "severity": "5.5",
        "description": "gnutls: GnuTLS Impacted by Inefficient DER Decoding in libtasn1 Leading to Remote DoS",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-12243"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-32988",
        "component": "libgnutls30t64",
        "severity": "5.5",
        "description": "gnutls: Vulnerability in GnuTLS otherName SAN export",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-32988"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-32989",
        "component": "libgnutls30t64",
        "severity": "5.5",
        "description": "gnutls: Vulnerability in GnuTLS SCT extension parsing",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-32989"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-32990",
        "component": "libgnutls30t64",
        "severity": "5.5",
        "description": "gnutls: Vulnerability in GnuTLS certtool template parsing",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-32990"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6395",
        "component": "libgnutls30t64",
        "severity": "5.5",
        "description": "gnutls: NULL pointer dereference in _gnutls_figure_common_ciphersuite()",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6395"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-31115",
        "component": "liblzma5",
        "severity": "5.5",
        "description": "xz: XZ has a heap-use-after-free bug in threaded .xz decoder",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-31115"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-10963",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "pam: Improper Hostname Interpretation in pam_access Leads to Access Control Bypass",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-10963"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6020",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Linux-pam directory Traversal",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6020"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8941",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Incomplete fix for CVE-2025-6020",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8941"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-10963",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "pam: Improper Hostname Interpretation in pam_access Leads to Access Control Bypass",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-10963"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6020",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Linux-pam directory Traversal",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6020"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8941",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Incomplete fix for CVE-2025-6020",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8941"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-10963",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "pam: Improper Hostname Interpretation in pam_access Leads to Access Control Bypass",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-10963"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6020",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Linux-pam directory Traversal",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6020"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8941",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Incomplete fix for CVE-2025-6020",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8941"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-10963",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "pam: Improper Hostname Interpretation in pam_access Leads to Access Control Bypass",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-10963"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6020",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Linux-pam directory Traversal",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6020"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8941",
        "component": "libpam0g",
        "severity": "5.5",
        "description": "linux-pam: Incomplete fix for CVE-2025-6020",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8941"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-57360",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: nm: potential segmentation fault when displaying symbols without version info",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-57360"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0840",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump.c disassemble_bytes stack-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0840"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1147",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils nm nm.c internal_strlen buffer overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1148",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld ldelfgen.c link_order_scan memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1176",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec heap-based overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1178",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld libbfd.c bfd_putl64 memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1178"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1181",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c _bfd_elf_gc_mark_rsec memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1181"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1182",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c bfd_elf_reloc_symbol_deleted_p memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1182"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3198",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump bucomm.c display_info memory leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3198"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5244",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils ld elflink.c elf_gc_sweep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5244"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5245",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: GNU Binutils objdump debug.c debug_type_samep memory corruption",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5245"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7545",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Heap Buffer Overflow",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7545"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7546",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils: Out-of-bounds Write Vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7546"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8225",
        "component": "libsframe1",
        "severity": "5.5",
        "description": "binutils: Binutils DWARF Section Handler Memory Leak",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8225"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-13716",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: Memory leak with the C++ symbol demangler routine in libiberty",
        "remediation": "The C++ symbol demangler routine in cplus-dem.c in libiberty, as distributed in GNU Binutils 2.29, allows remote attackers to cause a denial of service (excessive memory allocation and application crash) via a crafted file, as demonstrated by a call from the Binary File Descriptor (BFD) library (aka libbfd).",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-13716"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-1153",
        "component": "libsframe1",
        "severity": "2.0",
        "description": "binutils: GNU Binutils format.c bfd_set_format memory corruption",
        "remediation": "A vulnerability classified as problematic was found in GNU Binutils 2.43/2.44. Affected by this vulnerability is the function bfd_set_format of the file format.c. The manipulation leads to memory corruption. The attack can be launched remotely. The complexity of an attack is rather high. The exploitation appears to be difficult. Upgrading to version 2.45 is able to address this issue. The identifier of the patch is 8d97c1a53f3dc9fd8e1ccdb039b8a33d50133150. It is recommended to upgrade the affected component.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-1153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-29087",
        "component": "libsqlite3-0",
        "severity": "5.5",
        "description": "sqlite: Integer Overflow in SQLite concat_ws Function",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-29087"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-29088",
        "component": "libsqlite3-0",
        "severity": "5.5",
        "description": "sqlite: Denial of Service in SQLite",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-29088"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-3277",
        "component": "libsqlite3-0",
        "severity": "5.5",
        "description": "SQLite: integer overflow in SQLite",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-3277"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-6965",
        "component": "libsqlite3-0",
        "severity": "5.5",
        "description": "sqlite: Integer Truncation in SQLite",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-6965"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-7709",
        "component": "libsqlite3-0",
        "severity": "5.5",
        "description": "An integer overflow exists in the  FTS5 https://sqlite.org/fts5.html e ...",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-7709"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-9230",
        "component": "openssl",
        "severity": "5.5",
        "description": "openssl: Out-of-bounds read &amp; write in RFC 3211 KEK Unwrap",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-9230"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-13176",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: Timing side-channel in ECDSA signature computation",
        "remediation": "The FIPS modules in 3.4, 3.3, 3.2, 3.1 and 3.0 are affected by this issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-13176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-41996",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations",
        "remediation": "Validating the order of the public keys in the Diffie-Hellman Key Agreement Protocol, when an approved safe prime is used, allows remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations. The client may cause asymmetric resource consumption. The basic attack scenario is that the client must claim that it can only communicate with DHE, and the server must be configured to allow DHE and validate the order of the public key.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-41996"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-9143",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: Low-level invalid GF(2^m) parameters lead to OOB memory access",
        "remediation": "The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-9143"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-4598",
        "component": "libudev1",
        "severity": "5.5",
        "description": "systemd-coredump: race condition that allows a local attacker to crash a SUID program and gain read access to the resulting core dump",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-4598"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-12133",
        "component": "libtasn1-6",
        "severity": "5.5",
        "description": "libtasn1: Inefficient DER Decoding in libtasn1 Leading to Potential Remote DoS",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-12133"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-4598",
        "component": "libudev1",
        "severity": "5.5",
        "description": "systemd-coredump: race condition that allows a local attacker to crash a SUID program and gain read access to the resulting core dump",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-4598"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-0395",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: buffer overflow in the GNU C Library&#39;s assert()",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-0395"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-5702",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Vector register overwrite bug in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-5702"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-8058",
        "component": "locales",
        "severity": "5.5",
        "description": "glibc: Double free in glibc",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-8058"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-56433",
        "component": "passwd",
        "severity": "2.0",
        "description": "shadow-utils: Default subordinate ID configuration in /etc/login.defs could lead to compromise",
        "remediation": "shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g., uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks, potentially leading to account takeover, e.g., by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids, within local networks, that are within the range that can occur in /etc/subuid.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-56433"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-9230",
        "component": "openssl",
        "severity": "5.5",
        "description": "openssl: Out-of-bounds read &amp; write in RFC 3211 KEK Unwrap",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-9230"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-13176",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: Timing side-channel in ECDSA signature computation",
        "remediation": "The FIPS modules in 3.4, 3.3, 3.2, 3.1 and 3.0 are affected by this issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-13176"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-41996",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations",
        "remediation": "Validating the order of the public keys in the Diffie-Hellman Key Agreement Protocol, when an approved safe prime is used, allows remote attackers (from the client side) to trigger unnecessarily expensive server-side DHE modular-exponentiation calculations. The client may cause asymmetric resource consumption. The basic attack scenario is that the client must claim that it can only communicate with DHE, and the server must be configured to allow DHE and validate the order of the public key.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-41996"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-9143",
        "component": "openssl",
        "severity": "2.0",
        "description": "openssl: Low-level invalid GF(2^m) parameters lead to OOB memory access",
        "remediation": "The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-9143"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-56433",
        "component": "passwd",
        "severity": "2.0",
        "description": "shadow-utils: Default subordinate ID configuration in /etc/login.defs could lead to compromise",
        "remediation": "shadow-utils (aka shadow) 4.4 through 4.17.0 establishes a default /etc/subuid behavior (e.g., uid 100000 through 165535 for the first user account) that can realistically conflict with the uids of users defined on locally administered networks, potentially leading to account takeover, e.g., by leveraging newuidmap for access to an NFS home directory (or same-host resources in the case of remote logins by these local network users). NOTE: it may also be argued that system administrators should not have assigned uids, within local networks, that are within the range that can occur in /etc/subuid.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-56433"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-56406",
        "component": "perl-base",
        "severity": "5.5",
        "description": "perl: Perl 5.34, 5.36, 5.38 and 5.40 are vulnerable to a heap buffer overflow when transliterating non-ASCII bytes",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-56406"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-40909",
        "component": "perl-base",
        "severity": "5.5",
        "description": "perl: Perl threads have a working directory race condition where file operations may target unintended paths",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-40909"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-45582",
        "component": "tar",
        "severity": "5.5",
        "description": "tar: Tar path traversal",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-45582"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-31879",
        "component": "wget",
        "severity": "5.5",
        "description": "wget: authorization header disclosure on redirect",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-31879"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-53864",
        "component": "com.nimbusds:nimbus-jose-jwt",
        "severity": "5.8",
        "description": "com.nimbusds/nimbus-jose-jwt: Uncontrolled recursion in Connect2id Nimbus JOSE + JWT",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-53864"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2013-7285",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "9.8",
        "description": "XStream: remote code execution due to insecure XML deserialization",
        "remediation": "Xstream API versions up to 1.4.6 and version 1.4.10, if the security framework has not been initialized, may allow a remote attacker to run arbitrary shell commands by manipulating the processed input stream when unmarshaling XML or any supported format. e.g. JSON.",
        "reference": "https://avd.aquasec.com/nvd/cve-2013-7285"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2019-10173",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "9.8",
        "description": "xstream: remote code execution due to insecure XML deserialization (regression of  CVE-2013-7285)",
        "remediation": "It was found that xstream API version 1.4.10 before 1.4.11 introduced a regression for a previous deserialization flaw. If the security framework has not been initialized, it may allow a remote attacker to run arbitrary shell commands when unmarshalling XML or any supported format. e.g. JSON. (regression of CVE-2013-7285)",
        "reference": "https://avd.aquasec.com/nvd/cve-2019-10173"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2016-3674",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: enabled processing of external entities",
        "remediation": "Multiple XML external entity (XXE) vulnerabilities in the (1) Dom4JDriver, (2) DomDriver, (3) JDomDriver, (4) JDom2Driver, (5) SjsxpDriver, (6) StandardStaxDriver, and (7) WstxDriver drivers in XStream before 1.4.9 allow remote attackers to read arbitrary files via a crafted XML document.",
        "reference": "https://avd.aquasec.com/nvd/cve-2016-3674"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2017-7957",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: DoS when unmarshalling void type",
        "remediation": "XStream through 1.4.9, when a certain denyTypes workaround is not used, mishandles attempts to create an instance of the primitive type 'void' during unmarshalling, leading to a remote application crash, as demonstrated by an xstream.fromXML(\"<void/>\") call.",
        "reference": "https://avd.aquasec.com/nvd/cve-2017-7957"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2020-26217",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.1",
        "description": "XStream: remote code execution due to insecure XML deserialization when relying on blocklists",
        "remediation": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14.",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26217"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21341",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: allow a remote attacker to cause DoS only by manipulating the processed input stream",
        "remediation": "XStream is a Java library to serialize objects to XML and back again. In XStream before version 1.4.16, there is vulnerability which may allow a remote attacker to allocate 100% CPU time on the target system depending on CPU type or parallel execution of such a payload resulting in a denial of service only by manipulating the processed input stream. No user is affected who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the Security Framework, you will have to use at least version 1.4.16.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21341"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-29505",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "XStream: remote command execution attack by manipulating the processed input stream",
        "remediation": "XStream is software for serializing Java objects to XML and back again. A vulnerability in XStream versions prior to 1.4.17 may allow a remote attacker has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types is affected. The vulnerability is patched in version 1.4.17.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-29505"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39139",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of Xalan xsltc.trax.TemplatesImpl",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. A user is only affected if using the version out of the box with JDK 1.7u21 or below. However, this scenario can be adjusted easily to an external Xalan that works regardless of the version of the Java runtime. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39139"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39141",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.xml.internal.ws.client.sei.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39141"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39144",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of sun.tracing.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker has sufficient rights to execute commands of the host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39144"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39145",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapBindingEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39145"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39146",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of javax.swing.UIDefaults$ProxyLazyValue",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39146"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39147",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapSearchEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39147"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39148",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.toolkit.dir.ContextEnumerator",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39148"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39149",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.corba.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39149"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39150",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Server-side request forgery (SSRF) via unsafe deserialization of com.sun.xml.internal.ws.client.sei.*",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to request data from internal resources that are not publicly available only by manipulating the processed input stream with a Java runtime version 14 to 8. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the [Security Framework](https://x-stream.github.io/security.html#framework), you will have to use at least version 1.4.18.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39150"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39151",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of com.sun.jndi.ldap.LdapBindingEnumeration",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39151"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39152",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Server-side request forgery (SSRF) via unsafe deserialization of jdk.nashorn.internal.runtime.Source$URLData",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to request data from internal resources that are not publicly available only by manipulating the processed input stream with a Java runtime version 14 to 8. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. If you rely on XStream's default blacklist of the [Security Framework](https://x-stream.github.io/security.html#framework), you will have to use at least version 1.4.18.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39152"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39153",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of Xalan xsltc.trax.TemplatesImpl",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream, if using the version out of the box with Java runtime version 14 to 8 or with JavaFX installed. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39153"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39154",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.6",
        "description": "xstream: Arbitrary code execution via unsafe deserialization of javax.swing.UIDefaults$ProxyLazyValue",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. In affected versions this vulnerability may allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream. No user is affected, who followed the recommendation to setup XStream's security framework with a whitelist limited to the minimal required types. XStream 1.4.18 uses no longer a blacklist by default, since it cannot be secured for general purpose.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39154"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-43859",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "xstream: Injecting highly recursive collections or maps can cause a DoS",
        "remediation": "XStream is an open source java library to serialize objects to XML and back again. Versions prior to 1.4.19 may allow a remote attacker to allocate 100% CPU time on the target system depending on CPU type or parallel execution of such a payload resulting in a denial of service only by manipulating the processed input stream. XStream 1.4.19 monitors and accumulates the time it takes to add elements to collections and throws an exception if a set threshold is exceeded. Users are advised to upgrade as soon as possible. Users unable to upgrade may set the NO_REFERENCE mode to prevent recursion. See GHSA-rmr5-cpv2-vgjf for further details on a workaround if an upgrade is not possible.",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-43859"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-40151",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "xstream: Xstream to serialise XML data was vulnerable to Denial of Service attacks",
        "remediation": "Those using Xstream to seralize XML data may be vulnerable to Denial of Service attacks (DOS). If the parser is running on user supplied input, an attacker may supply content that causes the parser to crash by stackoverflow. This effect may support a denial of service attack.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-40151"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2022-41966",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "8.2",
        "description": "xstream: Denial of Service by injecting recursive collections or maps based on element&#39;s hash values raising a stack overflow",
        "remediation": "XStream serializes Java objects to XML and back again. Versions prior to 1.4.20 may allow a remote attacker to terminate the application with a stack overflow error, resulting in a denial of service only via manipulation the processed input stream. The attack uses the hash code implementation for collections and maps to force recursive hash calculation causing a stack overflow. This issue is patched in version 1.4.20 which handles the stack overflow and raises an InputManipulationException instead. A potential workaround for users who only use HashMap or HashSet and whose XML refers these only as default map or set, is to change the default implementation of java.util.Map and java.util per the code example in the referenced advisory. However, this implies that your application does not care about the implementation of the map and all elements are comparable.",
        "reference": "https://avd.aquasec.com/nvd/cve-2022-41966"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2024-47072",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "7.5",
        "description": "com.thoughtworks.xstream: XStream is vulnerable to a Denial of Service attack due to stack overflow from a manipulated binary input stream",
        "remediation": "XStream is a simple library to serialize objects to XML and back again. This vulnerability may allow a remote attacker to terminate the application with a stack overflow error resulting in a denial of service only by manipulating the processed input stream when XStream is configured to use the BinaryStreamDriver. XStream 1.4.21 has been patched to detect the manipulation in the binary input stream causing the the stack overflow and raises an InputManipulationException instead. Users are advised to upgrade. Users unable to upgrade may catch the StackOverflowError in the client code calling XStream if XStream is configured to use the BinaryStreamDriver.",
        "reference": "https://avd.aquasec.com/nvd/cve-2024-47072"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2020-26258",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.3",
        "description": "XStream: Server-Side Forgery Request vulnerability can be activated when unmarshalling",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26258"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2020-26259",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.8",
        "description": "XStream: arbitrary file deletion on the local host when unmarshalling",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2020-26259"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21342",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: SSRF via crafted input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21342"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21343",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: arbitrary file deletion on the local host via crafted input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21343"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21344",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: Unsafe deserizaliation of javax.sql.rowset.BaseRowSet",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21344"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21345",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.8",
        "description": "XStream: Unsafe deserizaliation of com.sun.corba.se.impl.activation.ServerTableEntry",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21345"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21346",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: Unsafe deserizaliation of sun.swing.SwingLazyValue",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21346"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21347",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: Unsafe deserizaliation of com.sun.tools.javac.processing.JavacProcessingEnvironment NameProcessIterator",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21347"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21348",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: ReDoS vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21348"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21349",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.1",
        "description": "XStream: SSRF can be activated unmarshalling with XStream to access data streams from an arbitrary URL referencing a resource in an intranet or the local host",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21349"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21350",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.3",
        "description": "XStream: Unsafe deserizaliation of com.sun.org.apache.bcel.internal.util.ClassLoader",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21350"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-21351",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "5.4",
        "description": "XStream: allow a remote attacker to load and execute arbitrary code from a remote host only by manipulating the processed input stream",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-21351"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2021-39140",
        "component": "com.thoughtworks.xstream:xstream",
        "severity": "6.5",
        "description": "xstream: Infinite loop DoS via unsafe deserialization of sun.reflect.annotation.AnnotationInvocationHandler",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2021-39140"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-48924",
        "component": "org.apache.commons:commons-lang3",
        "severity": "6.5",
        "description": "commons-lang/commons-lang: org.apache.commons/commons-lang3: Uncontrolled Recursion vulnerability in Apache Commons Lang",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48924"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-48988",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "7.5",
        "description": "tomcat: Apache Tomcat DoS in multipart upload",
        "remediation": "Users are recommended to upgrade to version 11.0.8, 10.1.42 or 9.0.106, which fix the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48988"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-48989",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "7.5",
        "description": "tomcat: http/2 &#34;MadeYouReset&#34; DoS attack through HTTP/2 control frames",
        "remediation": "Users are recommended to upgrade to one of versions 11.0.10, 10.1.44 or 9.0.108 which fix the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-48989"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-31650",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "5.5",
        "description": "tomcat: Apache Tomcat: DoS via malformed HTTP/2 PRIORITY_UPDATE frame",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-31650"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-49125",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "5.5",
        "description": "tomcat: Apache Tomcat: Security constraint bypass for pre/post-resources",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-49125"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-31651",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "2.0",
        "description": "tomcat: Apache Tomcat: Bypass of rules in Rewrite Valve",
        "remediation": "Users are recommended to upgrade to version [FIXED_VERSION], which fixes the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-31651"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-46701",
        "component": "org.apache.tomcat.embed:tomcat-embed-core",
        "severity": "2.0",
        "description": "tomcat: Apache Tomcat: Security constraint bypass for CGI scripts",
        "remediation": "Users are recommended to upgrade to version 11.0.7, 10.1.41 or 9.0.105, which fixes the issue.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-46701"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2023-51775",
        "component": "org.bitbucket.b_c:jose4j",
        "severity": "6.5",
        "description": "jose4j: denial of service via specially crafted JWE",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2023-51775"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-46551",
        "component": "rubygems:jruby-openssl",
        "severity": "5.5",
        "description": "jruby-openssl: jruby: JRuby-OpenSSL has hostname verification disabled by default",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-46551"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-22235",
        "component": "org.springframework.boot:spring-boot",
        "severity": "7.3",
        "description": "org.springframework.boot/spring-boot: Spring Boot EndpointRequest.to() creates wrong matcher if actuator endpoint is not exposed",
        "remediation": "*  Your application does not handle requests to /null\u00a0or this path does not need protection",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-22235"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-41232",
        "component": "org.springframework.security:spring-security-core",
        "severity": "9.1",
        "description": "Spring-Security: Spring Security authorization bypass for method security annotations on private methods",
        "remediation": "*  You have no Spring Security-annotated private methods",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41232"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-41248",
        "component": "org.springframework.security:spring-security-core",
        "severity": "7.5",
        "description": "org.springframework.security/spring-security-core: Spring Security authorization bypass",
        "remediation": "This CVE is published in conjunction with  CVE-2025-41249 https://spring.io/security/cve-2025-41249 .",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41248"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-22233",
        "component": "org.springframework:spring-context",
        "severity": "3.1",
        "description": "CVE-2024-38820 ensured Locale-independent, lowercase conversion for bo ...",
        "remediation": "This issue was responsibly reported by the TERASOLUNA Framework Development Team from NTT DATA Group Corporation.",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-22233"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-41249",
        "component": "org.springframework:spring-core",
        "severity": "7.5",
        "description": "org.springframework/spring-core: Spring Framework Annotation Detection Vulnerability",
        "remediation": "This CVE is published in conjunction with  CVE-2025-41248 https://spring.io/security/cve-2025-41248 .",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41249"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-41234",
        "component": "org.springframework:spring-web",
        "severity": "6.5",
        "description": "springframework: Reflected download attack in Spring Framework with non-ASCII headers",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41234"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-41242",
        "component": "org.springframework:spring-webmvc",
        "severity": "5.9",
        "description": "org.springframework/spring-webmvc: Spring Framework MVC path traversal vulnerability",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-41242"
      },
      {
        "tool": "Trivy",
        "type": "SCA Image Scan",
        "cve": "CVE-2025-46551",
        "component": "rubygems:jruby-openssl",
        "severity": "5.5",
        "description": "jruby-openssl: jruby: JRuby-OpenSSL has hostname verification disabled by default",
        "remediation": "",
        "reference": "https://avd.aquasec.com/nvd/cve-2025-46551"
      }
    ]
  },
  {
    "tool": "OWASP ZAP",
    "type": "DAST",
    "timestamp": "2025-10-21T07:37:59.992209+00:00",
    "target": "N/A",
    "results": [
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Content Security Policy (CSP) Header Not Set",
        "risk": "Medium (High)",
        "description": "<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.</p>",
        "uri": "http://127.0.0.1:8080",
        "evidence": "",
        "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header.</p>",
        "cwe": "693"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Content Security Policy (CSP) Header Not Set",
        "risk": "Medium (High)",
        "description": "<p>Content Security Policy (CSP) is an added layer of security that helps to detect and mitigate certain types of attacks, including Cross Site Scripting (XSS) and data injection attacks. These attacks are used for everything from data theft to site defacement or distribution of malware. CSP provides a set of standard HTTP headers that allow website owners to declare approved sources of content that browsers should be allowed to load on that page \u2014 covered types are JavaScript, CSS, HTML frames, fonts, images and embeddable objects such as Java applets, ActiveX, audio and video files.</p>",
        "uri": "http://127.0.0.1:8080/sitemap.xml",
        "evidence": "",
        "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Content-Security-Policy header.</p>",
        "cwe": "693"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Permissions Policy Header Not Set",
        "risk": "Low (Medium)",
        "description": "<p>Permissions Policy Header is an added layer of security that helps to restrict from unauthorized access or usage of browser/client features by web resources. This policy ensures the user privacy by limiting or specifying the features of the browsers can be used by the web resources. Permissions Policy provides a set of standard HTTP headers that allow website owners to limit which features of browsers can be used by the page such as camera, microphone, location, full screen etc.</p>",
        "uri": "http://127.0.0.1:8080",
        "evidence": "",
        "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Permissions-Policy header.</p>",
        "cwe": "693"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Permissions Policy Header Not Set",
        "risk": "Low (Medium)",
        "description": "<p>Permissions Policy Header is an added layer of security that helps to restrict from unauthorized access or usage of browser/client features by web resources. This policy ensures the user privacy by limiting or specifying the features of the browsers can be used by the web resources. Permissions Policy provides a set of standard HTTP headers that allow website owners to limit which features of browsers can be used by the page such as camera, microphone, location, full screen etc.</p>",
        "uri": "http://127.0.0.1:8080/robots.txt",
        "evidence": "",
        "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Permissions-Policy header.</p>",
        "cwe": "693"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Permissions Policy Header Not Set",
        "risk": "Low (Medium)",
        "description": "<p>Permissions Policy Header is an added layer of security that helps to restrict from unauthorized access or usage of browser/client features by web resources. This policy ensures the user privacy by limiting or specifying the features of the browsers can be used by the web resources. Permissions Policy provides a set of standard HTTP headers that allow website owners to limit which features of browsers can be used by the page such as camera, microphone, location, full screen etc.</p>",
        "uri": "http://127.0.0.1:8080/sitemap.xml",
        "evidence": "",
        "solution": "<p>Ensure that your web server, application server, load balancer, etc. is configured to set the Permissions-Policy header.</p>",
        "cwe": "693"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Storable and Cacheable Content",
        "risk": "Informational (Medium)",
        "description": "<p>The response contents are storable by caching components such as proxy servers, and may be retrieved directly from the cache, rather than from the origin server by the caching servers, in response to similar requests from other users. If the response data is sensitive, personal or user-specific, this may result in sensitive information being leaked. In some cases, this may even result in a user gaining complete control of the session of another user, depending on the configuration of the caching components in use in their environment. This is primarily an issue where \"shared\" caching servers such as \"proxy\" caches are configured on the local network. This configuration is typically found in corporate or educational environments, for instance.</p>",
        "uri": "http://127.0.0.1:8080",
        "evidence": "",
        "solution": "<p>Validate that the response does not contain sensitive, personal or user-specific information. If it does, consider the use of the following HTTP response headers, to limit, or prevent the content being stored and retrieved from the cache by another user:</p><p>Cache-Control: no-cache, no-store, must-revalidate, private</p><p>Pragma: no-cache</p><p>Expires: 0</p><p>This configuration directs both HTTP 1.0 and HTTP 1.1 compliant caching servers to not store the response, and to not retrieve the response (without validation) from the cache, in response to a similar request.</p>",
        "cwe": "524"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Storable and Cacheable Content",
        "risk": "Informational (Medium)",
        "description": "<p>The response contents are storable by caching components such as proxy servers, and may be retrieved directly from the cache, rather than from the origin server by the caching servers, in response to similar requests from other users. If the response data is sensitive, personal or user-specific, this may result in sensitive information being leaked. In some cases, this may even result in a user gaining complete control of the session of another user, depending on the configuration of the caching components in use in their environment. This is primarily an issue where \"shared\" caching servers such as \"proxy\" caches are configured on the local network. This configuration is typically found in corporate or educational environments, for instance.</p>",
        "uri": "http://127.0.0.1:8080/robots.txt",
        "evidence": "",
        "solution": "<p>Validate that the response does not contain sensitive, personal or user-specific information. If it does, consider the use of the following HTTP response headers, to limit, or prevent the content being stored and retrieved from the cache by another user:</p><p>Cache-Control: no-cache, no-store, must-revalidate, private</p><p>Pragma: no-cache</p><p>Expires: 0</p><p>This configuration directs both HTTP 1.0 and HTTP 1.1 compliant caching servers to not store the response, and to not retrieve the response (without validation) from the cache, in response to a similar request.</p>",
        "cwe": "524"
      },
      {
        "tool": "OWASP ZAP",
        "type": "DAST",
        "name": "Storable and Cacheable Content",
        "risk": "Informational (Medium)",
        "description": "<p>The response contents are storable by caching components such as proxy servers, and may be retrieved directly from the cache, rather than from the origin server by the caching servers, in response to similar requests from other users. If the response data is sensitive, personal or user-specific, this may result in sensitive information being leaked. In some cases, this may even result in a user gaining complete control of the session of another user, depending on the configuration of the caching components in use in their environment. This is primarily an issue where \"shared\" caching servers such as \"proxy\" caches are configured on the local network. This configuration is typically found in corporate or educational environments, for instance.</p>",
        "uri": "http://127.0.0.1:8080/sitemap.xml",
        "evidence": "",
        "solution": "<p>Validate that the response does not contain sensitive, personal or user-specific information. If it does, consider the use of the following HTTP response headers, to limit, or prevent the content being stored and retrieved from the cache by another user:</p><p>Cache-Control: no-cache, no-store, must-revalidate, private</p><p>Pragma: no-cache</p><p>Expires: 0</p><p>This configuration directs both HTTP 1.0 and HTTP 1.1 compliant caching servers to not store the response, and to not retrieve the response (without validation) from the cache, in response to a similar request.</p>",
        "cwe": "524"
      }
    ]
  }
]